
function linuxSnapshot (options = {}) {
  return new Promise((resolve, reject) => {
    listDisplays().then( async (screens) => {
      const screen = screens.find(options.screen ? screen => screen.id === options.screen : screen => screen.primary || screen.id === 'default') || screens[0]
      const tempFilename = path.join('/tmp', `tmp-screenshot.png`);
      let usesTempFile = false

      const filename = options.filename ? (options.filename.replace(/"/g, '\\"')) : '-'
      const execOptions =
        options.filename
          ? {}
          : {
              encoding: 'buffer',
              maxBuffer: maxBuffer(screens)
            }
      const filetype = options.format || guessFiletype(filename)

      let commandLine = ''

      //wayland override
      const flameshotAvailable = await checkExecutable('flameshot')
      const spectacleAvailable = await checkExecutable('spectacle')

  
      if (isWayland()){
        if ( isGNOME() || isUNITY() ) { return reject('Gnome/Unity and Wayland platform not supported.') }
        else if ( spectacleAvailable ){  options.linuxLibrary = 'spectacle'   }
        else if ( flameshotAvailable ){  options.linuxLibrary = 'flameshot'   }
        else {  return reject('Wayland platform detected. Please install Flameshot or Spectacle!')    }
      } 

      switch (options.linuxLibrary) {
        case 'spectacle':
          commandLine = `spectacle -b -n -o "${tempFilename}"`
          usesTempFile = true
          break
        case 'scrot': // Faster. Does not support crop.
          commandLine = `scrot "${filename}" -e -z "echo \\"${filename}\\""`
          break
        case 'flameshot': // wayland option
          commandLine = `flameshot full --raw `
          break
        case 'imagemagick':
        default:
          commandLine = `import -silent -window root -crop ${screen.crop} -screen ${filetype}:"${filename}" `
          break
      }

      exec(
        commandLine,
        execOptions,
        (err, stdout) => {
          if (err) {
            return reject(err)
          } else {

            if (usesTempFile) {
              try {
                const buffer = fs.readFileSync(tempFilename);
                return resolve(buffer);
              } catch (readErr) {
                return reject(readErr);
              }
            } else {
              return resolve(options.filename ? path.resolve(options.filename) : stdout)
            }
          }
        })
    })
  })
}